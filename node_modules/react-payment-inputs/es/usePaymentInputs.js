import './utils/cardTypes-4f45f8d3.js';
import './utils/validator-5620b2ce.js';
import { b as _slicedToArray, c as _objectSpread, d as _defineProperty, e as _objectWithoutProperties } from './chunk-7eee66c0.js';
import './utils/formatter-b0b2372d.js';
import utils from './utils/index.js';
import React from 'react';

function usePaymentCard() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      errorMessages = _ref.errorMessages,
      onBlur = _ref.onBlur,
      onChange = _ref.onChange,
      onError = _ref.onError,
      onTouch = _ref.onTouch;

  var cardNumberField = React.useRef();
  var expiryDateField = React.useRef();
  var cvcField = React.useRef();
  var zipField = React.useRef();
  /** ====== START: META STUFF ====== */

  var _React$useState = React.useState({
    cardNumber: false,
    expiryDate: false,
    cvc: false,
    zip: false
  }),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      touchedInputs = _React$useState2[0],
      setTouchedInputs = _React$useState2[1];

  var _React$useState3 = React.useState(false),
      _React$useState4 = _slicedToArray(_React$useState3, 2),
      isTouched = _React$useState4[0],
      setIsTouched = _React$useState4[1];

  var _React$useState5 = React.useState({
    cardNumber: undefined,
    expiryDate: undefined,
    cvc: undefined,
    zip: undefined
  }),
      _React$useState6 = _slicedToArray(_React$useState5, 2),
      erroredInputs = _React$useState6[0],
      setErroredInputs = _React$useState6[1];

  var _React$useState7 = React.useState(),
      _React$useState8 = _slicedToArray(_React$useState7, 2),
      error = _React$useState8[0],
      setError = _React$useState8[1];

  var _React$useState9 = React.useState(),
      _React$useState10 = _slicedToArray(_React$useState9, 2),
      cardType = _React$useState10[0],
      setCardType = _React$useState10[1];

  var _React$useState11 = React.useState(),
      _React$useState12 = _slicedToArray(_React$useState11, 2),
      focused = _React$useState12[0],
      setFocused = _React$useState12[1];

  var setInputError = React.useCallback(function (input, error) {
    setErroredInputs(function (erroredInputs) {
      if (erroredInputs[input] === error) return erroredInputs;
      var newError = error;

      var newErroredInputs = _objectSpread({}, erroredInputs, _defineProperty({}, input, error));

      if (error) {
        setError(error);
      } else {
        newError = Object.values(newErroredInputs).find(Boolean);
        setError(newError);
      }

      onError && onError(newError, newErroredInputs);
      return newErroredInputs;
    });
  }, []); // eslint-disable-line

  var setInputTouched = React.useCallback(function (input, value) {
    requestAnimationFrame(function () {
      if (document.activeElement.tagName !== 'INPUT') {
        setIsTouched(true);
      } else if (value === false) {
        setIsTouched(false);
      }
    });
    setTouchedInputs(function (touchedInputs) {
      if (touchedInputs[input] === value) return touchedInputs;

      var newTouchedInputs = _objectSpread({}, touchedInputs, _defineProperty({}, input, value));

      onTouch && onTouch(_defineProperty({}, input, value), newTouchedInputs);
      return newTouchedInputs;
    });
  }, []); // eslint-disable-line

  /** ====== END: META STUFF ====== */

  /** ====== START: CARD NUMBER STUFF ====== */

  var handleBlurCardNumber = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onBlur && props.onBlur(e);
      onBlur && onBlur(e);
      setFocused(undefined);
      setInputTouched('cardNumber', true);
    };
  }, [onBlur, setInputTouched]);
  var handleChangeCardNumber = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      var formattedCardNumber = e.target.value || '';
      var cardNumber = formattedCardNumber.replace(/\s/g, '');
      var cursorPosition = cardNumberField.current.selectionStart;
      var cardType = utils.cardTypes.getCardTypeByValue(cardNumber);
      setCardType(cardType);
      setInputTouched('cardNumber', false);
      props.onChange && props.onChange(e);
      onChange && onChange(e); // @ts-ignore

      cardNumberField.current.value = utils.formatter.formatCardNumber(cardNumber); // Due to the card number formatting, the selection cursor will fall to the end of
      // the input field. Here, we want to reposition the cursor to the correct place.

      requestAnimationFrame(function () {
        if (document.activeElement !== cardNumberField.current) return;

        if (cardNumberField.current.value[cursorPosition - 1] === ' ') {
          cursorPosition = cursorPosition + 1;
        }

        cardNumberField.current.setSelectionRange(cursorPosition, cursorPosition);
      });
      var cardNumberError = utils.validator.getCardNumberError(cardNumber, {
        errorMessages: errorMessages
      });

      if (!cardNumberError) {
        expiryDateField.current && expiryDateField.current.focus();
      }

      setInputError('cardNumber', cardNumberError);
    };
  }, [errorMessages, onChange, setInputError, setInputTouched]);
  var handleFocusCardNumber = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onFocus && props.onFocus();
      setFocused('cardNumber');
    };
  }, []);
  var handleKeyPressCardNumber = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      var formattedCardNumber = e.target.value || '';
      var cardNumber = formattedCardNumber.replace(/\s/g, '');
      props.onKeyPress && props.onKeyPress(e);

      if (e.keyCode !== utils.ENTER_KEY_CODE) {
        if (!utils.validator.isNumeric(e)) {
          e.preventDefault();
        }

        if (utils.validator.hasCardNumberReachedMaxLength(cardNumber)) {
          e.preventDefault();
        }
      }
    };
  }, []);
  var getCardNumberProps = React.useCallback(function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var refKey = _ref2.refKey,
        props = _objectWithoutProperties(_ref2, ["refKey"]);

    return _objectSpread(_defineProperty({
      'aria-label': 'Card number',
      autoComplete: 'cc-number',
      id: 'cardNumber',
      name: 'cardNumber',
      placeholder: 'Card number',
      type: 'tel'
    }, refKey || 'ref', cardNumberField), props, {
      onBlur: handleBlurCardNumber(props),
      onChange: handleChangeCardNumber(props),
      onFocus: handleFocusCardNumber(props),
      onKeyPress: handleKeyPressCardNumber(props)
    });
  }, [handleBlurCardNumber, handleChangeCardNumber, handleFocusCardNumber, handleKeyPressCardNumber]);
  /** ====== END: CARD NUMBER STUFF ====== */

  /** ====== START: EXPIRY DATE STUFF ====== */

  var handleBlurExpiryDate = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onBlur && props.onBlur(e);
      onBlur && onBlur(e);
      setFocused(undefined);
      setInputTouched('expiryDate', true);
    };
  }, [onBlur, setInputTouched]);
  var handleChangeExpiryDate = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      var expiryDate = e.target.value;
      setInputTouched('expiryDate', false);
      props.onChange && props.onChange(e);
      onChange && onChange(e);
      expiryDateField.current.value = utils.formatter.formatExpiry(e);
      var expiryDateError = utils.validator.getExpiryDateError(expiryDate, {
        errorMessages: errorMessages
      });

      if (!expiryDateError) {
        cvcField.current && cvcField.current.focus();
      }

      setInputError('expiryDate', expiryDateError);
    };
  }, [errorMessages, onChange, setInputError, setInputTouched]);
  var handleFocusExpiryDate = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onFocus && props.onFocus();
      setFocused('expiryDate');
    };
  }, []);
  var handleKeyDownExpiryDate = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onKeyDown && props.onKeyDown(e);

      if (e.keyCode === utils.BACKSPACE_KEY_CODE && !e.target.value) {
        cardNumberField.current && cardNumberField.current.focus();
      }
    };
  }, [cardNumberField]);
  var handleKeyPressExpiryDate = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      var formattedExpiryDate = e.target.value || '';
      var expiryDate = formattedExpiryDate.replace(' / ', '');
      props.onKeyPress && props.onKeyPress(e);

      if (e.keyCode !== utils.ENTER_KEY_CODE) {
        if (!utils.validator.isNumeric(e)) {
          e.preventDefault();
        }

        if (expiryDate.length >= 4) {
          e.preventDefault();
        }
      }
    };
  }, []);
  var getExpiryDateProps = React.useCallback(function () {
    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var refKey = _ref3.refKey,
        props = _objectWithoutProperties(_ref3, ["refKey"]);

    return _objectSpread(_defineProperty({
      'aria-label': 'Expiry date in format MM YY',
      autoComplete: 'cc-exp',
      id: 'expiryDate',
      name: 'expiryDate',
      placeholder: 'MM/YY',
      type: 'tel'
    }, refKey || 'ref', expiryDateField), props, {
      onBlur: handleBlurExpiryDate(props),
      onChange: handleChangeExpiryDate(props),
      onFocus: handleFocusExpiryDate(props),
      onKeyDown: handleKeyDownExpiryDate(props),
      onKeyPress: handleKeyPressExpiryDate(props)
    });
  }, [handleBlurExpiryDate, handleChangeExpiryDate, handleFocusExpiryDate, handleKeyDownExpiryDate, handleKeyPressExpiryDate]);
  /** ====== END: EXPIRY DATE STUFF ====== */

  /** ====== START: CVC STUFF ====== */

  var handleBlurCVC = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onBlur && props.onBlur(e);
      onBlur && onBlur(e);
      setFocused(undefined);
      setInputTouched('cvc', true);
    };
  }, [onBlur, setInputTouched]);
  var handleChangeCVC = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        cardType = _ref4.cardType;

    return function (e) {
      var cvc = e.target.value;
      setInputTouched('cvc', false);
      props.onChange && props.onChange(e);
      onChange && onChange(e);
      var cvcError = utils.validator.getCVCError(cvc, {
        cardType: cardType,
        errorMessages: errorMessages
      });

      if (!cvcError) {
        zipField.current && zipField.current.focus();
      }

      setInputError('cvc', cvcError);
    };
  }, [errorMessages, onChange, setInputError, setInputTouched]);
  var handleFocusCVC = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onFocus && props.onFocus();
      setFocused('cvc');
    };
  }, []);
  var handleKeyDownCVC = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onKeyDown && props.onKeyDown(e);

      if (e.keyCode === utils.BACKSPACE_KEY_CODE && !e.target.value) {
        expiryDateField.current && expiryDateField.current.focus();
      }
    };
  }, [expiryDateField]);
  var handleKeyPressCVC = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var _ref5 = arguments.length > 1 ? arguments[1] : undefined,
        cardType = _ref5.cardType;

    return function (e) {
      var formattedCVC = e.target.value || '';
      var cvc = formattedCVC.replace(' / ', '');
      props.onKeyPress && props.onKeyPress(e);

      if (e.keyCode !== utils.ENTER_KEY_CODE) {
        if (!utils.validator.isNumeric(e)) {
          e.preventDefault();
        }

        if (cardType && cvc.length >= cardType.code.length) {
          e.preventDefault();
        }

        if (cvc.length >= 4) {
          e.preventDefault();
        }
      }
    };
  }, []);
  var getCVCProps = React.useCallback(function () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var refKey = _ref6.refKey,
        props = _objectWithoutProperties(_ref6, ["refKey"]);

    return _objectSpread(_defineProperty({
      'aria-label': 'CVC',
      autoComplete: 'cc-csc',
      id: 'cvc',
      name: 'cvc',
      placeholder: cardType ? cardType.code.name : 'CVC',
      type: 'tel'
    }, refKey || 'ref', cvcField), props, {
      onBlur: handleBlurCVC(props),
      onChange: handleChangeCVC(props, {
        cardType: cardType
      }),
      onFocus: handleFocusCVC(props),
      onKeyDown: handleKeyDownCVC(props),
      onKeyPress: handleKeyPressCVC(props, {
        cardType: cardType
      })
    });
  }, [cardType, handleBlurCVC, handleChangeCVC, handleFocusCVC, handleKeyDownCVC, handleKeyPressCVC]);
  /** ====== END: CVC STUFF ====== */

  /** ====== START: ZIP STUFF ====== */

  var handleBlurZIP = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onBlur && props.onBlur(e);
      onBlur && onBlur(e);
      setFocused(undefined);
      setInputTouched('zip', true);
    };
  }, [onBlur, setInputTouched]);
  var handleChangeZIP = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      var zip = e.target.value;
      setInputTouched('zip', false);
      props.onChange && props.onChange(e);
      onChange && onChange(e);
      var zipError = utils.validator.getZIPError(zip, {
        errorMessages: errorMessages
      });
      setInputError('zip', zipError);
    };
  }, [errorMessages, onChange, setInputError, setInputTouched]);
  var handleFocusZIP = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onFocus && props.onFocus();
      setFocused('zip');
    };
  }, []);
  var handleKeyDownZIP = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onKeyDown && props.onKeyDown(e);

      if (e.keyCode === utils.BACKSPACE_KEY_CODE && !e.target.value) {
        cvcField.current && cvcField.current.focus();
      }
    };
  }, [cvcField]);
  var handleKeyPressZIP = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return function (e) {
      props.onKeyPress && props.onKeyPress(e);

      if (e.keyCode !== utils.ENTER_KEY_CODE) {
        if (!utils.validator.isNumeric(e)) {
          e.preventDefault();
        }
      }
    };
  }, []);
  var getZIPProps = React.useCallback(function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var refKey = _ref7.refKey,
        props = _objectWithoutProperties(_ref7, ["refKey"]);

    return _objectSpread(_defineProperty({
      autoComplete: 'off',
      id: 'zip',
      maxLength: '6',
      name: 'zip',
      placeholder: 'ZIP',
      type: 'tel'
    }, refKey || 'ref', zipField), props, {
      onBlur: handleBlurZIP(props),
      onChange: handleChangeZIP(props),
      onFocus: handleFocusZIP(props),
      onKeyDown: handleKeyDownZIP(props),
      onKeyPress: handleKeyPressZIP(props)
    });
  }, [handleBlurZIP, handleChangeZIP, handleFocusZIP, handleKeyDownZIP, handleKeyPressZIP]);
  /** ====== END: ZIP STUFF ====== */

  /** ====== START: CARD IMAGE STUFF ====== */

  var getCardImageProps = React.useCallback(function () {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var images = props.images || {};
    return _objectSpread({
      'aria-label': cardType ? cardType.displayName : 'Placeholder card',
      children: images[cardType ? cardType.type : 'placeholder'] || images.placeholder,
      width: '1.5em',
      height: '1em',
      viewBox: '0 0 24 16'
    }, props);
  }, [cardType]);
  /** ====== END: CARD IMAGE STUFF ====== */
  // Set default field errors

  React.useLayoutEffect(function () {
    if (zipField.current) {
      var zipError = utils.validator.getZIPError(zipField.current.value, {
        errorMessages: errorMessages
      });
      setInputError('zip', zipError);
    }

    if (cvcField.current) {
      var cvcError = utils.validator.getCVCError(cvcField.current.value, {
        errorMessages: errorMessages
      });
      setInputError('cvc', cvcError);
    }

    if (expiryDateField.current) {
      var expiryDateError = utils.validator.getExpiryDateError(expiryDateField.current.value, {
        errorMessages: errorMessages
      });
      setInputError('expiryDate', expiryDateError);
    }

    if (cardNumberField.current) {
      var cardNumberError = utils.validator.getCardNumberError(cardNumberField.current.value, {
        errorMessages: errorMessages
      });
      setInputError('cardNumber', cardNumberError);
    }
  }, [errorMessages, setInputError]); // Format default values

  React.useLayoutEffect(function () {
    if (cardNumberField.current) {
      cardNumberField.current.value = utils.formatter.formatCardNumber(cardNumberField.current.value);
    }

    if (expiryDateField.current) {
      expiryDateField.current.value = utils.formatter.formatExpiry({
        target: expiryDateField.current
      });
    }
  }, []); // Set default card type

  React.useLayoutEffect(function () {
    if (cardNumberField.current) {
      var _cardType = utils.cardTypes.getCardTypeByValue(cardNumberField.current.value);

      setCardType(_cardType);
    }
  }, []);
  return {
    getCardImageProps: getCardImageProps,
    getCardNumberProps: getCardNumberProps,
    getExpiryDateProps: getExpiryDateProps,
    getCVCProps: getCVCProps,
    getZIPProps: getZIPProps,
    wrapperProps: {
      error: error,
      focused: focused,
      isTouched: isTouched
    },
    meta: {
      cardType: cardType,
      erroredInputs: erroredInputs,
      error: error,
      focused: focused,
      isTouched: isTouched,
      touchedInputs: touchedInputs
    }
  };
}

export default usePaymentCard;
